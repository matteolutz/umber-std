import "core.ub";
import "heap.ub";

// Implement logic, to include system relevant things depending on actual system
import "linux.ub";

import "cstr.ub";

fun print_char_ptr(arr: char *, len: number): number {
    return sys_write(1, arr, len);
};

fun print_str(str: string, len: number): number {
    return print_char_ptr(str as char *, len);
};

fun print_strl(str: string): number {
    return print_str(str, cstrlen(str as char *));
};

fun print_char_ptr_l(ptr: char *): number {
    return print_char_ptr(ptr, cstrlen(ptr));
};

fun throw(msg: char *, len: number): void {
    print_strl("\n\n\u001b[31m[ERROR]\u001b[0m ");
    print_char_ptr(msg, len);
    print_strl("\n\nExiting with status code \u001b[31;1m1\u001b[0m...\n\n");
    sys_exit(1);
    return;
};

fun throwc(msg: char *): void {
    return throw(msg, cstrlen(msg));
};

fun itoa(n: number, base: number, buf_end: char *mut): number {
    (buf_end as char *mut) @= '\0';
    let mut current: char *mut = buf_end-1;

    let mut t: number = n;

    while true {
        let mut new: number = ('0' as number) + (t % base);

        // Skips from ascii numbers to letters, to correctly represent hex numbers
        if new > 57 {
            new = (new % 57) + ('A' as number) - 1;
        };

        (current -= sizeof[char]) @= new as char;

        t /= base;

        if t == 0 { break; };
    };

    if n < 0 {
        (current -= sizeof[char]) @= '-';
    };

    return (buf_end - current) as number;
};

fun print_num(n: number, base: number): void {
    let bufferSize: number = 128;

    let begin_ptr: char *mut = malloc(bufferSize) as char *mut;
    let buf_end: char *mut = begin_ptr + bufferSize;

    let size: number = itoa(n, base, buf_end);

    print_char_ptr((buf_end - size) as char *, size);

    free(begin_ptr as void *mut);

    return;
};

fun println_num(n: number, base: number): void {
    print_num(n, base);
    print_str("\n", 1);
    return;
};

fun get_args_arr(argc: number, args: char *): char ** {

    let buff: char **mut = malloc(argc * 8) as char **mut;

    let mut curr_begin: char * = args;
    let mut curr: char * = curr_begin;

    let mut count: number = 0;

    while true {
        if count == argc { break; };
        
        if *curr == '\0' {
            buff[count] @= curr_begin;
            count += 1;

            curr += 1;
            curr_begin = curr;
            continue;
        };
        
        curr += 1;
    };

    return buff as char **;
};


fun memcpy(dest: void *mut, src: void *, n: number): void {
    let a: char *mut = dest as char *mut;
    let b: char * = src as char *;
    for let mut i: number = 0; i < n; i += 1 {
        a[i] @= *b[i];
    };
    return;
};